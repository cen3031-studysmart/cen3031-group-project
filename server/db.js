import db from 'oracledb';
import sql from 'sql-template-tag';
import dotenv from 'dotenv';
dotenv.config({path: ".env"});

/**
 * @type {string}
 */
const user = process.env.DB_USER;

/**
 * @type {string}
 */
const password = process.env.DB_PASSWORD;

/**
 * @type {string}
 */
const connectString = 'oracle.cise.ufl.edu:1521/orcl';

/**
 * Creates and returns a database connection instance
 * @returns{db.Connection} - Oracle instance
 */
async function createConnection() {
    try {
        const connection = await db.getConnection({ user, password, connectString });
        // Note from Emmanuel: Let me know if you don't have privileges to execute this line
        await connection.execute(sql`ALTER SESSION SET nls_date_format = 'DD-Mon-YYYY HH24:MI:SS'`)
        return connection;
    } catch (e) {
        console.error(e);
    }

    return null;
}

/**
 * Creates a user in the database
 * @param {string} userId - The user's ID generated by Clerk. It must be
 * between 1 and 100 characters.
 */
export async function createUser(userId) {
    if (typeof userId != 'string' && !(userId instanceof String)) {
        throw new Error('The argument userId must be a string.');
    }

    if (userId.length < 1 || userId.length > 100) {
        throw new Error('The argument userId must be between 1 and 100 characters.');
    }

    let connection;
    try {
        connection = await createConnection();

        await connection.execute(sql`INSERT INTO "EMMANUELNIFAKOS".studysmart_user VALUES (${userId}, CURRENT_DATE)`);
        await connection.commit();
    } catch (e) {
        console.error(e);
    } finally {
        await connection.close();
    }
}

/**
 * Creates a generated summary in the database
 * @param {string} title - Title of the summary
 * @param {string} owner - The user ID to whom the summary belongs
 * @param {string} content - Content of the summary
 */
export async function createSummary(title, owner, content) {
    let connection;
    try {
        connection = await createConnection();

        await connection.execute(sql`INSERT INTO "EMMANUELNIFAKOS".studysmart_summary (title, owner, content) VALUES (${title}, ${owner}, ${content})`);
        await connection.commit();
    } catch (e) {
        console.error(e);
    } finally {
        await connection.close();
    }
}

/**
 * @typedef {{ question: string, answer: string }} Flashcard
 */

/**
 * Creates a flashcard deck in the database
 * @param {string} title - Title of the summary
 * @param {string} owner - The user ID to whom the summary belongs
 * @param {Flashcard[]} content - Flashcards in JSON format
 */
export async function createFlashcardDeck(title, owner, content) {
    let connection;
    try {
        connection = await createConnection();

        await connection.execute(sql`INSERT INTO "EMMANUELNIFAKOS".studysmart_flashcard_deck (title, owner, content) VALUES (${title}, ${owner}, ${JSON.stringify(content)})`);
        await connection.commit();
    } catch (e) {
        console.error(e);
    } finally {
        await connection.close();
    }
}

/**
 * @typedef {{ question: string, options: string[], answer: string }} QuizQuestion
 */

/**
 * Creates a quiz in the database
 * @param {string} title - Title of the summary
 * @param {string} owner - The user ID to whom the summary belongs
 * @param {QuizQuestion[]} content - Flashcards in JSON format
 */
export async function createQuiz(title, owner, content) {
    let connection;
    try {
        connection = await createConnection();

        await connection.execute(sql`INSERT INTO "EMMANUELNIFAKOS".studysmart_quiz (title, owner, content) VALUES (${title}, ${owner}, ${JSON.stringify(content)})`);
        await connection.commit();
    } catch (e) {
        console.error(e);
    } finally {
        await connection.close();
    }
}

/**
 * @typedef {{ summaries: string, flashcards: string, quizzes: string }} UserData
 */

/**
 * Returns all user data, including quizzes, summaries, and flashcard decks
 * @param {string} userId - ID of the user
 * @return {UserData} userData - User's summaries, flashcard decks, and quizzes
 */
export async function getUserData(userId) {
    let connection;
    try {
        connection = await createConnection();

        const userExists = (await connection.execute(sql`SELECT * FROM studysmart_user WHERE id = ${userId}`)).rows.length == 1;

        if (!userExists) {
            return {
                status: 'failed',
                message: `The user "${userId}" does not exist.`
            };
        }

        const summaries = (await connection.execute(sql`SELECT JSON_OBJECT(*) FROM studysmart_summary WHERE owner = ${userId}`)).rows;
        const flashcards = (await connection.execute(sql`SELECT JSON_OBJECT(*) FROM studysmart_flashcard_deck WHERE owner = ${userId}`)).rows;
        const quizzes = (await connection.execute(sql`SELECT JSON_OBJECT(*) FROM studysmart_quiz WHERE owner = ${userId}`)).rows;

        return {
            status: 'success',
            result: userDataKeysToLowercase(normalizeUserPropertyNames(normalizeJSONUserData({ summaries, flashcards, quizzes })))
        }
    } catch (e) {
        return {
            status: 'failed',
            message: e
        }
    } finally {
        if (connection) {
            await connection.close();
        } else {
            console.warn('db.js: db connection is null. Make sure you\'re connected to the UF VPN')
        }
    }
}

function normalizeJSONUserData(data) {
    const summaries = data.summaries.map(([summary]) => JSON.parse(summary));
    const flashcards = data.flashcards.map(([flashcard]) => JSON.parse(flashcard));
    const quizzes = data.quizzes.map(([quiz]) => JSON.parse(quiz));

    return { summaries, flashcards, quizzes };
}

function normalizeUserPropertyNames({ summaries, flashcards, quizzes }) {

    return {
        summaries: summaries.map(({ ID, TITLE, CREATED_AT, CONTENT }) => ({ date: CREATED_AT, ID, TITLE, CONTENT })),
        flashcards: flashcards.map(({ ID, TITLE, CREATED_AT, CONTENT }) => ({ date: CREATED_AT, ID, TITLE, CONTENT })),
        quizzes: quizzes.map(({ ID, TITLE, CREATED_AT, CONTENT }) => ({ date: CREATED_AT, ID, TITLE, CONTENT }))
    }

}

function userDataKeysToLowercase({ summaries, flashcards, quizzes }) {
    const newSummaries = summaries.map(JSONKeysToLowercase);
    const newFlashcards = flashcards.map(JSONKeysToLowercase);
    const newQuizzes = quizzes.map(JSONKeysToLowercase);

    console.log('obj');
    console.log({
        summaries: newSummaries,
        flashcards: newFlashcards,
        quizzes: newQuizzes
    });
    
    return {
        summaries: newSummaries,
        flashcards: newFlashcards,
        quizzes: newQuizzes
    };
}

function JSONKeysToLowercase(obj) {

    let key, keys = Object.keys(obj);
    let n = keys.length;
    let newObject = {};
    while (n--) {
        key = keys[n];
        newObject[key.toLowerCase()] = obj[key];
    }

    return newObject;
}
